==============================
Process-Level Provenance Model
==============================

Introduction
------------

The `prov <https://github.com/trungdong/prov>`_ library
provides an implementation of the
`W3C Provenance Model <https://www.w3.org/TR/prov-overview/>`_.
This library assumes we are recording process-level provenance,
so it makes simplifying assumptions about
entities, activities and relations.

This provenance capture is for reconstructing which
processes read and wrote which files, so we assume that
each time a process runs, the PROV records are saved
and that the PROV records from many processes are assembled
in order to form a coherent causal chain. That's what we
want to support.

The core-provenance-model records every object with a unique
identifier in a namespace. How do we do that in these circumstances?

 - A file is copied.
 - A file is written over the old version with the same name.
 - A process appends to a file.
 - The multiprocess library starts a pool of subprocesses.
 - A script starts a set of processes on a cluster.

Let's break process-level provenance recording into four stages:

 1. What the code author specifies.
 2. Individual records, which are assertions about entity, agent, or activity.
 3. A complete provenance document generated by a single process.
 4. Collation of records into a narrative.

Let's start with number three, the complete provenance document,
because it conforms to W3C-PROV.

Process-level Provenance Document
---------------------------------

This subsection is a specification for what a tool reading
process-level provenance expects to find.
It might help to look at the
`W3C Prov Primer <https://www.w3.org/TR/prov-primer/>`_.
A provenance document is the Python prov library's term for
the root of a Bundle of Records.

Attributes that are part of the PROV standard are
marked with a dagger (ǂ). Attributes that are optional
for records but should be filled in eventually are marked
with an asterisk (*). For example, the end time of an activity
may not be known.

Default Namespaces
^^^^^^^^^^^^^^^^^^
We will need a bunch of organization-specific namespaces
which are specified during initialization.

 - `is` This is the namespace of instances of things.
 - `people` This the namespace for individuals, which here are usernames.
 - `doc` These are files or tables.
 - `code` This refers to code, probably in a repository.

A couple of additional namespaces will be assumed.

 - `foaf` Friend of a friend. http://xmlns.com/foaf/0.1/
 - `dct` The Dublin core. http://purl.org/dc/terms/
 - `prov` The W3C PROV namespace. http://www.w3.org/ns/prov#
 - `unk` A namespace to use when you're confused about
   which one to use. http://example.com/unknown

You would set these according to your organization. For instance,::

    my_org = "https://healthdata.org"
    namespaces = {
        "is": my_org + "/instances",
        "people": my_org + "/people",
        "code": my_org + "/code",
        "doc": my_org + "/document"
    }
    model = provda.model.ProcessDocument(namespaces)


Process Instance
^^^^^^^^^^^^^^^^
This is a unix process or Windows process. It represents a running
program on a computer. It is an Entity. When a process runs, it gives
itself a unique name using the `is` namespace and a UUID.
A process instance must have:

 - *id* ǂ a unique identifier in the `is` namespace. A UUID works.
 - *startTime* ǂ* Start time of the activity.
 - *endTime* ǂ* End time of the activity.
 - *prov:Type* ǂ This is an attribute with the value `prov:SoftwareAgent`.
 - *unk:pid* * A Unix process id, or pid, as in os.getpid().
 - *unk:ppid* * A Unix parent process id, or ppid.
 - Environment variables.

If another process refers to a process instance, it may refer to it
anonymously, as in, "I started three hundred processes, with the property
that they have these task IDs," or "I started a Pool of five
processes which will have my process as a parent."

Script Source
^^^^^^^^^^^^^
The source code of a process is an Entity in the `code` namespace.
Its id isn't unique. It's the name of the script within its
git repository. It has a version, however, which is the
git remote called "origin" and the hash of the branch that made it.
The process Used the script source.

 - *id* ǂ The object hash of the script in Git, or its full path if not in Git.
 - *prov:type* ǂ The name of the script relative to its repository root.
 - *unk:realPath* * The path to the script.
 - *unk:version_remote* * The Git remote, if it exists.
 - *unk:version_branch* * The Git branch, if it exists.
 - *unk:version_branch_hash* The hash of the Git branch, if it exists.

We could relate the running instance of the script to a collection
of entities that represent libraries, operating system, and
the script itself. Consider this a useful start.

User
^^^^
The unix or Windows username of the account under which
the script is running is the User entity. It's in the `people`
namespace. The process `wasAssociatedWith` the user.
This is a PROV Agent.

 - *id* ǂ A username in the `people` namespace. Should be the university id.
 - *prov:type* ǂ Equal to `prov:Person`


File
^^^^
A file is in the `doc` namespace, and its ID is its path.
A file that is written `wasGeneratedBy` the process, and the process
`used` a file that is read. The path isn't unique, even on the
same filesystem. It helps to record the time a file is read or
written. This library doesn't record SHA1 hashes, but that could
be done separately and added. Writing a file should be recorded
*after* the file is written, and reading a file should be recorded
*before* the file is read.

Each file also records a role for the file which records what
role this file plays for this process. The role could just
be the kind of data in the file (a model entity in statistics models).

 - *id* ǂ In the `doc` namespace, it's the logical file name.
 - *prov:type* ǂ This should be "document".
 - *unk:role* * This is the model entity for our computation.


Database Table
^^^^^^^^^^^^^^
These are treated like files, except that the ID is
the database host, schema, and table name. As for files,
a role is added.

 - *id* ǂ In the `doc` namespace, it's database/schema/table.
 - *prov:type* ǂ This should be "document".
 - *unk:database* * The hostname.
 - *unk:schema* * The schema.
 - *unk:table* * The table.
 - *unk:role* * This is the model entity for our computation.

Collection of Processes
^^^^^^^^^^^^^^^^^^^^^^^
A Collection is a PROV Entity which contains other entities.
This particular collection contains Entities which represent
batch job tasks, each named by its batch job id. Then the
current process entity started these. This is a collection.

 - *id* ǂ In the `is` namespace. We can name it with a UUID.
 - *prov:type* ǂ Equal to "prov:collection".
 - *unk:role* * This is the name of the computational stage.

Each process collection contains multiple activities which
are

 - *id* ǂ In the `is` namespace, but it's either an SGE job ID
   or a process ID. The SGE job ID may be a job task ID, as in
   "327.4".

These IDs aren't unique, but they are unique within the document
and can be fixed to match the UUIDs of the tasks that ran later.



Process-level Provenance as Individual Records
----------------------------------------------
While a process is running, it creates provenance. Each
of these moments, creating a file or starting a subprocess,
generates a sequence of entities and relations. Sometimes
these entities and relations are incomplete.
Even so, we would like to send these
records to the provenance store so that we can collate an intermediate
representation of the state of computation.

The corner cases where incomplete or indefinite information will
require later processing are the following.

  - Any relation in a provenance document is itself an instance
    and, in the absence of an explicit, unique ID, will be given
    a document-relative ID, which is sometimes just an underscore.
    That seems OK, as long as the entities in the relation are
    unique.
  - Writing to a file uses the path as a unique ID, but writing to
    the same file again should have a different ID.
  - When multiprocessing starts a sub-process, this library will
    automatically select a unique UUID for the sub-process,
    and it will also specify its parent PID. That parent PID is
    the only link to the process that started the sub-process,
    and it needs to have the same machine name and user name.
  - A script that starts batch jobs will start a collection of
    processes, each of which uses the batch job id as an identifier.
    Each of these corresponds to a process which will choose its
    UUID when it runs. The batch job id will be in the environment
    variables of the batch job when it runs.

We assume each record will be sent individually as a set of key-value
pairs, probably stored in JSON. The W3C-PROV model supports actual
JSON, but it allows for lists and dictionaries and nesting, which we
can't assume in logging frameworks or in, for instance, logstash.
Therefore, we will serialize as key-value pairs containing

 - The PROV record type (entity or relation)
 - The instance name of that PROV record
 - The UUID of the unix or Windows process generating this records.
 - A date and time.
 - All formal attributes of that PROV record type.
 - Every informal attribute we append must be a simple key-value pair.

We could send records as strings containing XML, or JSON, or PROV-N.
The goal in breaking them out is to make the records more accessible to
searches in ElasticSearch. You could retrieve all UUIDs within a
time range, then get all records associated with those UUIDs, and
then do a reconstruction of a provenance narrative from that set.


What the Code Author Specifies
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The interface for the author of the code starts with a setup
of the provenance model to point to namespaces for
instances, people, code, and documents. We limit interaction with
provenance to a few assertions.

 - *Write file* Gives the path name and role.
 - *Read file* Gives the path name and role.
 - *Write table* Gives host, schema, table and role.
 - *Read table* Gives host, schema, table and role.
 - *Start tasks* Gives task ids which are process ids or batch job ids.

Given the assumption that all of these assertions are made by
a process, each of the entities are used by or generated by that
process implicitly.


Collation into a Narrative
^^^^^^^^^^^^^^^^^^^^^^^^^^
During generation of provenance, the ids of many entities were
not unique, but all of the provenance records can be grouped into
process documents, each generated by a unique entity, the unix or Windows
process, which does have a unique UUID. We could bundle
records so that each record is sent as "entity with UUID X says that
this process used this file," but it seems enough to include the
UUID of the generating process as a parameter to reach record.
